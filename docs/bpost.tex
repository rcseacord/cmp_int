\documentclass[11pt,letterpaper]{article}
%\usepackage{ncc_whitepaper}
\usepackage[english]{babel}
\documentclass{article}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}



\newcommand{\papertitle}{Tool Release: Safe Integer Comparison in C}
\newcommand{\paperabstract}{\blindtext}
\newcommand{\docversion}{1.0}


\title{Tool Release: Safe Integer Comparison in C}
\author{Anton Gerasimov\\
Robert Seacord\\
Aaron Ballman}


% \newcommand{\draft} % Comment this out when distributing
\draftcheck

\makeindex

\begin{document}
%%% Header, ToC and title
\maketitle
\newpage
\thispagestyle{fancy}
\clearpage
\section*{Table of Contents}
\makeatletter
\renewcommand\tableofcontents{\@starttoc{toc}} % Remove heading from ToC
\makeatother
\bgroup%
%%%\addfontfeatures{BoldFeatures={Color=nccred}}
\hypersetup%
\tableofcontents
\egroup%
\thispagestyle{nccsection}
\pagebreak
%%%


\section{Introduction}

In this paper, we discuss the challenges that arise from integer comparison in C (Section~
\ref{sec:overview}) and describe the library that we are releasing (Section~\ref{sec:cimplementation}), and compare it with the C++ implementation (Section~\ref{sec:cppimplementation}). 
We also give suggestions for use (Section~\ref{sec:suggestions}) and directions of future work (Section~\ref{sec:futurework}).

\section{Overview– Integer Security in C}
\label{sec:overview}

\subsection{Background }

Signed / unsigned comparison is a major source of defects and software vulnerabilities in C and C++ programming [Seacord 2005, Stroustrup 2019].

@book{SEISecureCoding2013,
title = {Secure Coding in C and C++},
edition={Second},
year={2013},
publisher={Addison-Wesley Professional},
}

Bjarne Stroustrup.  "Don’t add to the signed/unsigned mess". 2019-02-14 https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1491r0.pdf


Type conversion errors can be of two types, explicit and implicit. The former occurs when the developer makes a type cast which can lead to data loss, when for example a cast from a larger width to a smaller width unsigned number. Implicit conversion occurs by the compiler without direction from the developer, and is prompted by an operation that implicitly forces a conversion of a variable type that the developer had no intention of effecting. It is true that this conversion follows a defined integer conversion rank, but the impact is unpredictable. There may be no issue, for example when a promotion occurs to a higher precision type with , or there may be data loss arising from a demotion. Our current purpose, however, is to discuss the scenario of implicit type conversion occurring because of comparison operations.


\subsection{Concrete examples of sneaky problems}
Any type of comparison (==,=!,\textless=,\textless,\textgreater=,\textgreater) can provoke an implicit type conversion when the operands are of different types. This can occur in a number of ways. We begin with the below simple example:

\begin{lstlisting}[style=CStyle]
signed int x=-1;
unsigned int y=1;
printf(“beware the output of x<y is actually %d\n”,x<y);
\end{lstlisting}


Here, there is an implicit conversion of x from signed to unsigned, and hence the -1 is then “wrapped around” to UINT_MAX-1. 

We consider now the following:

\begin{lstlisting}[style=CStyle]
short x=1;
short y=2;
if(x-sizeof(y)>1){
  		printf("this was not expected to be verified");}
\end{lstlisting}

In this example, several things occur at once. First, both x and y will be promoted to a signed int because an arithmetic operation is performed upon them. Next, x will be converted to unsigned int implicitly because of the subtraction of sizeof(y), but the latter is equal to 2, with the unsigned result therefore corresponding to UINT\_MAX-1, which nicely satisfies the condition even though the developer might have expected 1-2>1 and therefore false.

\subsection{Existing palliative measures}


i.	Solutions in code
1.	Type convert then compare
ii.	Compiler flags and warnings

\section{C++ Solution}
\label{sec:cppimplementation}

C++ Definition and features (discussion of OOP/template?)

\blindtext
\blindlist{itemize}

\section{C Solution}
\label{sec:cimplementation}
a.	Our definition
b.	Portable/no
c.	What it prevents
d.	Performance differences

\section{Suggestions For Use}
\label{sec:suggestions}

\section{Future Work}
\label{sec:futurework}



\printindex
\end{document}

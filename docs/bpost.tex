\documentclass[11pt,letterpaper]{article}
%\usepackage{ncc_whitepaper}
\usepackage[english]{babel}
\documentclass{article}
\usepackage{xcolor}
\usepackage{listings}

\definecolor{mGreen}{rgb}{0,0.6,0}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\definecolor{backgroundColour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{CStyle}{
    backgroundcolor=\color{backgroundColour},   
    commentstyle=\color{mGreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{mGray},
    stringstyle=\color{mPurple},
    basicstyle=\footnotesize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    language=C
}



\newcommand{\papertitle}{Tool Release: Safe Integer Comparison in C}
\newcommand{\paperabstract}{\blindtext}
\newcommand{\docversion}{1.0}


\title{Tool Release: Safe Integer Comparison in C}
\author{Anton Gerasimov\\
Robert Seacord\\
Aaron Ballman}


% \newcommand{\draft} % Comment this out when distributing
\draftcheck

\makeindex

\begin{document}
%%% Header, ToC and title
\maketitle
\newpage
\thispagestyle{fancy}
\clearpage
\section*{Table of Contents}
\makeatletter
\renewcommand\tableofcontents{\@starttoc{toc}} % Remove heading from ToC
\makeatother
\bgroup%
%%%\addfontfeatures{BoldFeatures={Color=nccred}}
\hypersetup%
\tableofcontents
\egroup%
\thispagestyle{nccsection}
\pagebreak
%%%


\section{Introduction}

In this paper, we discuss the challenges that arise from integer comparison in C (Section~
\ref{sec:overview}) and describe the library that we are releasing (Section~\ref{sec:cimplementation}), and compare it with the C++ implementation (Section~\ref{sec:cppimplementation}). 
We also give suggestions for use (Section~\ref{sec:suggestions}) and directions of future work (Section~\ref{sec:futurework}).

\section{Overview– Integer Security in C}
\label{sec:overview}

\subsection{Background }

Signed / unsigned comparison is a major source of defects and software vulnerabilities in C and C++ programming [Seacord 2005, Stroustrup 2019].

@book{10.5555/2530475,
author = {Seacord, Robert C.},
title = {Secure Coding in C and C++},
year = {2013},
isbn = {0321822137},
publisher = {Addison-Wesley Professional},
edition = {2nd},
}

Bjarne Stroustrup.  "Don’t add to the signed/unsigned mess". 2019-02-14 https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1491r0.pdf

For example, the following expression:

\begin{lstlisting}[style=CStyle]
 -1 > 0u 
\end{lstlisting}

evaluates to \texttt{true} which can be surprising to inexperienced programmers.
This particular comparison is between two integer literals, so the first step in this process is determining the type of these literals.
Even this process is complicated as the type depends on the implementation-defined ranges of integer types, the values, and any suffixes used by the integer literal.
The left-hand side of this comparison has the value \texttt{-1}.
This is actually the integer literal one preceeded by the unary negation operator.
The integer literal 1 in this example has the type \texttt{int}.
The right-hand side of this expression consists solely of the integer literal \texttt{0u}.
The \texttt{u} in this example is an integer literal suffix meaning unsigned.
The integer literal \texttt{0u}  has the type \texttt{unsigned int}.
Before the comparison can be evaluated expression, C must balance the two operands to a common type.
The process for doing so is called the \emph{usual arithmetic conversions}.
To determine the common type, each type is assigned a conversion rank according to the \emph{integer conversion rank} rules.
The rank of any unsigned integer type is equal to the rank of the corresponding signed integer type.
If the operand that has unsigned integer type has rank \texttt{>=} the rank of the operand with signed integer type, the operand with signed integer type is converted to the type of the operand with unsigned integer type.
In this particular example, this means that \texttt{-1} is converted to the type \texttt{unsigned int}, and the comparison is performed between two integer values of this type.
Because unsigned types cannot represent negative values, when \texttt{-1} is converted to \texttt{unsigned int} the bit pattern represents the value \texttt {UINT\_MAX} the maximum value that can be represented as \texttt{unsigned int}.
At this point, it should be clear why \texttt{-1 > 0u} evaluates to \texttt{true}, as \texttt {UINT\_MAX} is greater than zero.

The general \emph{integer conversion rank} rules and \emph{usual arithmetic conversions} are more complicated of course.
This example does not even involve \emph{integer promotions}, which are only applied to an object or expression with an integer type whose integer conversion rank is less than or equal to the rank of \texttt{int} and \texttt{unsigned int}.  

Any comparison operator (==,=!,\textless=,\textless,\textgreater=,\textgreater) can provoke an implicit type conversion when the operands are of different types. 
This can occur in a number of ways. 
The following example is similiar to the previous one, but uses objects with defined, but different integer types:

\begin{lstlisting}[style=CStyle]
signed int x=-1;
unsigned int y=1;
printf(“beware the output of x < y is actually %d\n”, x < y);
\end{lstlisting}

Again, the rvalue on the left-hand side of the comparison operator is converted from signed int to unsigned int as a result of the usual arithmetic conversion.
The result is that the expression \texttt{x < y} evaluates to false.

We consider now the following:

\begin{lstlisting}[style=CStyle]
signed char user_input_len;
char user_input_buffer[]="msg";
user_input_len=get_unvalidated_user_input(...);

if(user_input_len==sizeof(user_input_buffer)){
	printf("continue unintended program execution");
	}	
 	
\end{lstlisting}

In this example,  \texttt{user\_input\_len} is promoted to \texttt{unsigned int} as explained above. However, if we now suppose that the user has populated \texttt{user\_input\_len} as -252, then the equality check in the if statement will in fact be verified, and thus this validation check has been bypassed because of the unintended behavior of the implicit type conversion. 


\subsection{Existing palliative measures}

\subsubsection{Compiler flags and warnings}
The most immediate way to address implicit conversions arising because of comparison is to use compiler flags. In GCC, the relevant flags are -Wsign-compare, which checks for comparisons between signed and unsigned types, as well as -Wsign-conversion, which warns that an implicit conversion may have changed the sign of a conversion. Both of these checks are included in the -Wextra flag.

(https://gcc.gnu.org/onlinedocs/gcc/Warning-Options.html)

In Clang, the main flag is -Wsign-conversion, which also controls the more granular

-Wimplicit-int-conversion, -Wint-conversion, and -Wsign-conversion.

(https://clang.llvm.org/docs/DiagnosticsReference.html#wimplicit-int-conversion)

In MSVC, like with GCC and Clang, the default setting does not warn about implicit conversions. There is however the C4018 level 3 compiler warning , which notifies the developer that an operator had forced an implicit conversion from signed to unsigned, with the same trigger for level 4 warning C4388. Likewise, level 4 warning C4389 notifies that an "==" or "!=" operation involved signed and unsigned variables. However, these warnings must be used with care as it has been detected that error C4018 is not triggered when the operands are of different size, and Microsoft has closed the ticket without resolving the issue, as it was deemed of insufficient importance. 

(https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-3-c4018?view=msvc-170

https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/c4388?view=msvc-170

https://learn.microsoft.com/en-us/cpp/error-messages/compiler-warnings/compiler-warning-level-4-c4389?view=msvc-170

https://developercommunity.visualstudio.com/t/warning-c4018-does-not-work-when-the-sizes-of-type/335285)



\subsubsection{Solutions in code}
 1)Type convert then compare




\section{C++ Solution}
\label{sec:cppimplementation}

C++ Definition and features (discussion of OOP/template?)

\blindtext
\blindlist{itemize}

\section{C Solution}
\label{sec:cimplementation}
a.	Our definition
b.	Portable/no
c.	What it prevents
d.	Performance differences

\section{Suggestions For Use}
\label{sec:suggestions}

\section{Future Work}
\label{sec:futurework}



\printindex
\end{document}
